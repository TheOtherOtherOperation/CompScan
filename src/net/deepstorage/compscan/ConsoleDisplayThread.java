/**
 * CompScan - a tool for estimating the compressibility of a dataset.
 * 
 * Copyright (c) 2016 DeepStorage, LLC (deepstorage.net) and Ramon A. Lovato (ramonalovato.com).
 * 
 * See the file LICENSE for copying permission.
 */
package net.deepstorage.compscan;

import net.deepstorage.compscan.CompScan.MutableCounter;
import net.deepstorage.compscan.CompScan.Results;

import java.util.Date;
import java.util.concurrent.atomic.AtomicLong;
import java.io.*;
import java.text.*;
import java.nio.file.Path;
import java.util.stream.Stream;

/**
 * Provides interactive console output for CompScan.
 * 
 * @author Ramon A. Lovato
 * @version 1.0
 */
public class ConsoleDisplayThread extends Thread {
   private static final DateFormat df=new SimpleDateFormat("MM/dd/yy HH:mm:ss");
   
	private Results[] results;
	private String lastString;
	private long startTime;
	private long elapsedTime;
	private AtomicLong[] hashCounters;
	private boolean printUsage;
   private Path logFile;
   private PrintWriter log;
	
	/**
	 * Constructor.
	 * 
	 * @param results Results object for which to display output.
	 */
	public ConsoleDisplayThread(
      Results[] results, AtomicLong[] hashCounters, boolean printUsage,
      Path logFile
	){
		this.results = results;
		this.hashCounters = hashCounters;
		lastString = "";
		startTime = System.currentTimeMillis();
		this.printUsage = printUsage;
      this.logFile=logFile;
	}

	@Override
	public void run(){
      if(logFile!=null) try{
         log=new PrintWriter(new FileWriter(logFile.toFile()), true);
      }
      catch(IOException e){
         System.out.println("WARNING: couldn't open the log file: "+logFile);
      }
		while (!isInterrupted()) {
			try {
				sleep(1000);
			} catch (InterruptedException e) {
				break;
			}
			elapsedTime = System.currentTimeMillis() - startTime;
			clearLastLine();
			printProgress();
		}
		System.out.println();
		if(log!=null) try{
		   log.close();
		}
		catch(Exception ignore){}
	}
	
	/**
	 * Clear the last line of console output generated by this thread.
	 */
	private void clearLastLine() {
		String s = new String(new char[lastString.length()]).replace('\0', '\b');
		System.out.print(s);
	}
	
	/**
	 * Estimate of the current memory usage.
	 * 
	 * @return A formatted string of the memory estimates.
	 */
	private String getMemoryEstimates() {
		Runtime runtime = Runtime.getRuntime();

		StringBuilder sb = new StringBuilder();
		long maxMemory = runtime.maxMemory();
		long allocatedMemory = runtime.totalMemory();
		long freeMemory = runtime.freeMemory();
		
		String formatString = "%0" + String.valueOf(
				maxMemory / CompScan.ONE_MB).length() + "dMB";

		sb.append(String.format(formatString, freeMemory / CompScan.ONE_MB) + "/");
		sb.append(String.format(formatString, allocatedMemory / CompScan.ONE_MB) + "/");
		sb.append(String.format(formatString, maxMemory / CompScan.ONE_MB) + "/");
		sb.append(String.format(formatString, (freeMemory + (maxMemory - allocatedMemory)) / CompScan.ONE_MB));
		
		return sb.toString();
	}
	
	/**
	 * Print a progress line.
	 */
	private void printProgress() {
		String usageString = "";
		if (printUsage) {
			usageString = String.format("    Memory estimate (free/alloc/max/total): %s", getMemoryEstimates());
		}
      Results fileStat=results[results.length-1];
		String s = String.format("Elapsed time: %1$d sec    Files read: %2$d    Megabytes read: %3$.2f    " +
								 "Unique hashes: %4$s%5$s",
				elapsedTime / 1000,
            fileStat.get("files read"),
            ((float) fileStat.get("bytes read"))/((float) CompScan.ONE_MB),
            String.join("/",Stream.of(hashCounters).map(hc->(String)hc.toString()).toArray(size->new String[size])),
				usageString);
		lastString = s;
		System.out.print(s);
		if(log!=null) log.println("["+df.format(new Date())+"] "+s);
	}
}
